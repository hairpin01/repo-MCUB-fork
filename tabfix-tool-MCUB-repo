# author: @Hairpin00
# version: 2.2.0
# description: —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç—Å—Ç—É–ø–æ–≤
# requires: tabfix-tool

import os
import sys
import zipfile
import tempfile
import asyncio
from pathlib import Path

try:
    from tabfix import TabFixAPI, TabFixConfig, process_files, BatchResult
except ImportError as e:
    print(f"Import error: {e}")
    sys.exit(1)

from telethon import events, Button

def register(kernel):
    client = kernel.client
    processing_users = set()
    user_sessions = {}

    class UserSession:
        def __init__(self, user_id):
            self.user_id = user_id
            self.temp_dir = None
            self.processed_files = []
            self.current_batch = None
            self.config = TabFixConfig()
            self.api = TabFixAPI(config=self.config)
            self.zip_password = None

        def cleanup(self):
            if self.temp_dir and os.path.exists(self.temp_dir):
                import shutil
                shutil.rmtree(self.temp_dir)
            self.temp_dir = None
            self.processed_files = []
            self.current_batch = None
            self.zip_password = None

    def get_session(user_id):
        if user_id not in user_sessions:
            user_sessions[user_id] = UserSession(user_id)
        return user_sessions[user_id]

    async def extract_zip_with_password(zip_path, extract_dir, password):
        try:
            with zipfile.ZipFile(zip_path, 'r') as zipf:
                if password:
                    zipf.setpassword(password.encode('utf-8'))

                extracted_files = []
                for file_info in zipf.infolist():
                    if not file_info.is_dir():
                        try:
                            zipf.extract(file_info, extract_dir)
                            extracted_files.append(Path(extract_dir) / file_info.filename)
                        except RuntimeError as e:
                            if "encrypted" in str(e) and password:
                                try:
                                    zipf.extract(file_info, extract_dir, pwd=password.encode('utf-8'))
                                    extracted_files.append(Path(extract_dir) / file_info.filename)
                                except:
                                    continue
                            continue
                        except:
                            continue

                return extracted_files, len(zipf.infolist())
        except Exception as e:
            return [], 0

    @kernel.register_command('tabfix')
    # —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞ –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç—Å—Ç—É–ø–æ–≤
    async def tabfix_handler(event):
        user_id = event.sender_id
        session = get_session(user_id)

        if user_id in processing_users:
            await event.edit("‚è≥ –£–∂–µ –∏–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...")
            return

        args = event.text.split()[1:] if len(event.text.split()) > 1 else []

        if not args or args[0] == "help":
            help_text = (
                "üìñ **TabFix Help**\n\n"
                "**–ö–æ–º–∞–Ω–¥—ã:**\n"
                "`.tabfix` [—Ñ–ª–∞–≥–∏] (–æ—Ç–≤–µ—Ç –Ω–∞ —Ñ–∞–π–ª/–∞—Ä—Ö–∏–≤)\n"
                "`.tabfix batch` ‚Äî –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞–∫–µ—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É\n"
                "`.tabfix cancel` ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É\n"
                "`.tabfix status` ‚Äî —Å—Ç–∞—Ç—É—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏\n"
                "`.tabfix config` ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n"
                "**–§–ª–∞–≥–∏:**\n"
                "‚Ä¢ `-s N` ‚Äî –ø—Ä–æ–±–µ–ª–æ–≤ –≤ —Ç–∞–±–µ (–¥–µ—Ñ–æ–ª—Ç: 4)\n"
                "‚Ä¢ `--json` ‚Äî —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å JSON\n"
                "‚Ä¢ `--no-mixed` ‚Äî –Ω–µ —Ñ–∏–∫—Å–∏—Ç—å —Å–º–µ—à–∞–Ω–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã\n"
                "‚Ä¢ `--no-trail` ‚Äî –Ω–µ —É–¥–∞–ª—è—Ç—å –ø—Ä–æ–±–µ–ª—ã –≤ –∫–æ–Ω—Ü–µ\n"
                "‚Ä¢ `--no-smart` ‚Äî –≤—ã–∫–ª. —É–º–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É\n"
                "‚Ä¢ `--dry-run` ‚Äî —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≤–µ—Ä–∫–∞\n"
                "‚Ä¢ `--zip` ‚Äî –≤–µ—Ä–Ω—É—Ç—å –∞—Ä—Ö–∏–≤–æ–º\n"
                "‚Ä¢ `--password –ü–ê–†–û–õ–¨` ‚Äî –ø–∞—Ä–æ–ª—å –¥–ª—è –∞—Ä—Ö–∏–≤–∞\n\n"
                "**–ü—Ä–∏–º–µ—Ä—ã:**\n"
                "`.tabfix -s 2 --json`\n"
                "`.tabfix --dry-run --password mypass`\n"
                "`.tabfix --zip --password 1234`\n"
                "`.tabfix batch` (–∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª—ã)"
            )
            await event.edit(help_text)
            return

        if args[0] == "cancel":
            if user_id in processing_users:
                processing_users.remove(user_id)
                session.cleanup()
                await event.edit("‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞")
            else:
                await event.edit("‚õàÔ∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            return

        if args[0] == "status":
            if session.current_batch:
                batch = session.current_batch
                status_text = (
                    f"üìä **–°—Ç–∞—Ç—É—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏:**\n"
                    f"‚Ä¢ –§–∞–π–ª–æ–≤: {batch.total_files}\n"
                    f"‚Ä¢ –ò–∑–º–µ–Ω–µ–Ω–æ: {batch.changed_files}\n"
                    f"‚Ä¢ –û—à–∏–±–æ–∫: {batch.failed_files}\n"
                    f"‚Ä¢ –í—Ä–µ–º—è: {batch.duration:.1f}—Å"
                )
                await event.edit(status_text)
            else:
                await event.edit("üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            return

        if args[0] == "config":
            config = session.config
            config_text = (
                f"‚öôÔ∏è **–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:**\n"
                f"‚Ä¢ –ü—Ä–æ–±–µ–ª–æ–≤ –≤ —Ç–∞–±–µ: {config.spaces}\n"
                f"‚Ä¢ –ò—Å–ø—Ä–∞–≤–ª—è—Ç—å —Å–º–µ—à–∞–Ω–Ω—ã–µ: {config.fix_mixed}\n"
                f"‚Ä¢ –£–¥–∞–ª—è—Ç—å –ø—Ä–æ–±–µ–ª—ã –≤ –∫–æ–Ω—Ü–µ: {config.fix_trailing}\n"
                f"‚Ä¢ –£–º–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞: {config.smart_processing}\n"
                f"‚Ä¢ –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å JSON: {config.format_json}\n"
                f"‚Ä¢ –†–µ–∂–∏–º –ø—Ä–æ–≤–µ—Ä–∫–∏: {config.dry_run}"
            )
            await event.edit(config_text)
            return

        if args[0] == "batch":
            session.cleanup()
            session.temp_dir = tempfile.mkdtemp(prefix="tabfix_")
            await event.edit(
                "üì¶ **–ü–∞–∫–µ—Ç–Ω—ã–π —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω**\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª—ã –∏–ª–∏ –∞—Ä—Ö–∏–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.tabfix process` —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.tabfix cancel` –¥–ª—è –æ—Ç–º–µ–Ω—ã."
            )
            return

        if args[0] == "process":
            if not session.temp_dir or not os.path.exists(session.temp_dir):
                await event.edit("‚õàÔ∏è –°–Ω–∞—á–∞–ª–∞ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–∞–∫–µ—Ç–Ω—ã–π —Ä–µ–∂–∏–º: `.tabfix batch`")
                return

            files = list(Path(session.temp_dir).rglob("*"))
            files = [f for f in files if f.is_file()]

            if not files:
                await event.edit("‚õàÔ∏è –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                return

            processing_users.add(user_id)
            await event.edit(f"‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ {len(files)} —Ñ–∞–π–ª–æ–≤...")

            try:
                results = process_files(files, config=session.config)
                session.current_batch = results

                changed_files = [r for r in results.individual_results if r.changed]

                if changed_files:
                    zip_path = Path(session.temp_dir) / "processed.zip"
                    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                        if session.zip_password:
                            zipf.setpassword(session.zip_password.encode('utf-8'))
                        for result in changed_files:
                            zipf.write(result.filepath, result.filepath.name)

                    caption = (
                        f"üì¶ **–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ñ–∞–π–ª–æ–≤:** {results.total_files}\n"
                        f"üìù **–ò–∑–º–µ–Ω–µ–Ω–æ:** {results.changed_files}\n"
                        f"‚õàÔ∏è **–û—à–∏–±–æ–∫:** {results.failed_files}\n"
                        f"‚è±Ô∏è **–í—Ä–µ–º—è:** {results.duration:.1f}—Å"
                    )
                    if session.zip_password:
                        caption += f"\nüîê **–ü–∞—Ä–æ–ª—å:** `{session.zip_password}`"

                    await client.send_file(
                        event.chat_id,
                        zip_path,
                        caption=caption
                    )
                    await event.delete()
                else:
                    status_text = (
                        f"üìä **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:**\n"
                        f"‚Ä¢ –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: {results.total_files}\n"
                        f"‚Ä¢ –ò–∑–º–µ–Ω–µ–Ω–æ: {results.changed_files}\n"
                        f"‚Ä¢ –û—à–∏–±–æ–∫: {results.failed_files}\n"
                        f"‚Ä¢ –í—Ä–µ–º—è: {results.duration:.1f}—Å"
                    )
                    await event.edit(status_text)

            except Exception as e:
                await event.edit(f"‚õàÔ∏è **–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏:** {str(e)}")
            finally:
                processing_users.remove(user_id)
                session.cleanup()
            return

        opts = {
            "spaces": 4,
            "fix_mixed": True,
            "fix_trailing": True,
            "smart_processing": True,
            "format_json": False,
            "dry_run": False,
            "check_only": False,
            "return_zip": False,
            "password": None
        }

        i = 0
        while i < len(args):
            arg = args[i]
            if arg == "-s" and i + 1 < len(args):
                try:
                    opts["spaces"] = int(args[i + 1])
                    i += 1
                except ValueError:
                    pass
            elif arg == "--json":
                opts["format_json"] = True
            elif arg == "--no-mixed":
                opts["fix_mixed"] = False
            elif arg == "--no-trail":
                opts["fix_trailing"] = False
            elif arg == "--no-smart":
                opts["smart_processing"] = False
            elif arg == "--dry-run" or arg == "--check":
                opts["check_only"] = True
                opts["dry_run"] = True
            elif arg == "--zip":
                opts["return_zip"] = True
            elif arg == "--password" and i + 1 < len(args):
                opts["password"] = args[i + 1]
                session.zip_password = args[i + 1]
                i += 1
            i += 1

        if not event.is_reply:
            await event.edit(
                "**–û—à–∏–±–∫–∞:** –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Ñ–∞–π–ª –∏–ª–∏ –∞—Ä—Ö–∏–≤.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.tabfix help` –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏."
            )
            return

        reply = await event.get_reply_message()
        if not reply.document and not reply.file:
            await event.edit("**–û—à–∏–±–∫–∞:** –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ–∞–π–ª.")
            return

        processing_users.add(user_id)
        await event.edit("‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞...")

        temp_dir = tempfile.mkdtemp(prefix="tabfix_")
        file_paths = []

        try:
            is_zip = False
            if reply.document and reply.document.mime_type in ['application/zip', 'application/x-zip-compressed']:
                is_zip = True
            elif reply.file and reply.file.name and reply.file.name.endswith('.zip'):
                is_zip = True

            if is_zip:
                zip_path = Path(temp_dir) / "archive.zip"
                await reply.download_media(zip_path)

                extracted_files, total_in_zip = await extract_zip_with_password(zip_path, temp_dir, opts["password"])
                file_paths = extracted_files

                if not file_paths and total_in_zip > 0:
                    if opts["password"]:
                        await event.edit(
                            "‚õàÔ∏è **–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ñ–∞–π–ª—ã –∏–∑ –∞—Ä—Ö–∏–≤–∞!**\n"
                            "–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:\n"
                            "‚Ä¢ –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å\n"
                            "‚Ä¢ –ê—Ä—Ö–∏–≤ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω\n"
                            "‚Ä¢ –§–∞–π–ª—ã –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã –¥—Ä—É–≥–∏–º –º–µ—Ç–æ–¥–æ–º"
                        )
                    else:
                        await event.edit(
                            "üîê **–ê—Ä—Ö–∏–≤ –∑–∞—â–∏—â–µ–Ω –ø–∞—Ä–æ–ª–µ–º!**\n"
                            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–ª–∞–≥ `--password –ü–ê–†–û–õ–¨`\n"
                            "–ü—Ä–∏–º–µ—Ä: `.tabfix --password 123 --zip`"
                        )
                    processing_users.remove(user_id)
                    if os.path.exists(temp_dir):
                        import shutil
                        shutil.rmtree(temp_dir)
                    return
            else:
                file_path = await reply.download_media(temp_dir)
                file_paths.append(Path(file_path))

            if not file_paths:
                await event.edit("‚õàÔ∏è **–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏**")
                processing_users.remove(user_id)
                if os.path.exists(temp_dir):
                    import shutil
                    shutil.rmtree(temp_dir)
                return

            session.config = TabFixConfig(
                spaces=opts["spaces"],
                fix_mixed=opts["fix_mixed"],
                fix_trailing=opts["fix_trailing"],
                smart_processing=opts["smart_processing"],
                format_json=opts["format_json"],
                dry_run=opts["dry_run"],
                check_only=opts["check_only"]
            )

            results = process_files(file_paths, config=session.config)
            session.current_batch = results

            if len(file_paths) == 1 and not opts["return_zip"]:
                result = results.individual_results[0]

                if result.errors:
                    await event.edit(f"‚õàÔ∏è **–û—à–∏–±–∫–∞:** `{result.errors[0]}`")
                elif opts["check_only"] or opts["dry_run"]:
                    if result.needs_formatting or result.changed:
                        changes = result.changes if result.changes else ["—Ç—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ"]
                        await event.edit(f"üìã **–ü—Ä–æ–≤–µ—Ä–∫–∞:** {', '.join(changes)}")
                    else:
                        await event.edit("‚úÖ –§–∞–π–ª —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞–º.")
                else:
                    if result.changed:
                        changes_str = ", ".join(result.changes) if result.changes else "–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ"
                        caption = f"üìù **–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:** {changes_str}"
                        await client.send_file(event.chat_id, file_paths[0], caption=caption, reply_to=reply.id)
                        await event.delete()
                    else:
                        await event.edit("‚úÖ –§–∞–π–ª —É–∂–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∞–≤–∏–ª–∞–º.")
            else:
                changed_files = [r for r in results.individual_results if r.changed]

                if changed_files or opts["return_zip"]:
                    zip_path = Path(temp_dir) / "processed.zip"
                    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                        if opts["password"]:
                            zipf.setpassword(opts["password"].encode('utf-8'))
                        for result in results.individual_results:
                            if result.filepath.exists():
                                arcname = result.filepath.relative_to(temp_dir) if result.filepath.is_relative_to(temp_dir) else result.filepath.name
                                zipf.write(result.filepath, arcname)

                    caption = (
                        f"üì¶ **–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ñ–∞–π–ª–æ–≤:** {results.total_files}\n"
                        f"üìù **–ò–∑–º–µ–Ω–µ–Ω–æ:** {results.changed_files}\n"
                        f"‚õàÔ∏è **–û—à–∏–±–æ–∫:** {results.failed_files}\n"
                        f"‚è±Ô∏è **–í—Ä–µ–º—è:** {results.duration:.1f}—Å"
                    )
                    if opts["password"]:
                        caption += f"\nüîê **–ü–∞—Ä–æ–ª—å:** `{opts['password']}`"

                    await client.send_file(
                        event.chat_id,
                        zip_path,
                        caption=caption,
                        reply_to=reply.id
                    )
                    await event.delete()
                else:
                    status_text = (
                        f"üìä **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:**\n"
                        f"‚Ä¢ –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: {results.total_files}\n"
                        f"‚Ä¢ –ò–∑–º–µ–Ω–µ–Ω–æ: {results.changed_files}\n"
                        f"‚Ä¢ –û—à–∏–±–æ–∫: {results.failed_files}\n"
                        f"‚Ä¢ –í—Ä–µ–º—è: {results.duration:.1f}—Å"
                    )
                    await event.edit(status_text)

        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"Debug: {error_details}")
            await event.edit(f"‚õàÔ∏è **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:** `{type(e).__name__}: {str(e)[:200]}`")
        finally:
            processing_users.remove(user_id)
            if os.path.exists(temp_dir):
                import shutil
                shutil.rmtree(temp_dir)

    @client.on(events.NewMessage(outgoing=True, func=lambda e: e.is_private))
    async def batch_file_handler(event):
        user_id = event.sender_id
        session = get_session(user_id)

        if not session.temp_dir or not os.path.exists(session.temp_dir):
            return

        if event.document or event.file:
            await event.edit("‚è≥ –°–æ—Ö—Ä–∞–Ω—è—é —Ñ–∞–π–ª...")
            try:
                file_path = await event.download_media(session.temp_dir)
                file_name = Path(file_path).name

                if file_name.endswith('.zip'):
                    try:
                        extracted_files, _ = await extract_zip_with_password(file_path, session.temp_dir, session.zip_password)
                        os.remove(file_path)
                        if extracted_files:
                            await event.edit(f"‚úÖ **–ê—Ä—Ö–∏–≤ —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω! –ò–∑–≤–ª–µ—á–µ–Ω–æ {len(extracted_files)} —Ñ–∞–π–ª–æ–≤.**\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ —Ñ–∞–π–ª—ã –∏–ª–∏ `.tabfix process`")
                        else:
                            await event.edit(f"‚õàÔ∏è **–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞–∫–æ–≤–∞—Ç—å –∞—Ä—Ö–∏–≤!**\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–æ–ª—å –∏–ª–∏ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –∞—Ä—Ö–∏–≤–∞.")
                    except Exception as e:
                        await event.edit(f"‚õàÔ∏è **–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ –∞—Ä—Ö–∏–≤–∞:** {str(e)}")
                else:
                    await event.edit(f"‚úÖ –§–∞–π–ª `{file_name}` —Å–æ—Ö—Ä–∞–Ω–µ–Ω\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ —Ñ–∞–π–ª—ã –∏–ª–∏ `.tabfix process`")
            except Exception as e:
                await event.edit(f"‚õàÔ∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {str(e)}")
        elif event.message.text and event.message.text.startswith('.'):
            return
        elif event.message.text:
            session.cleanup()
            await event.edit("‚õàÔ∏è –ü–∞–∫–µ—Ç–Ω—ã–π —Ä–µ–∂–∏–º –æ—Ç–º–µ–Ω–µ–Ω")

    @kernel.register_command('tabfix_stats')
    # —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–æ–¥—É–ª—è TabFix
    async def stats_handler(event):
        total_users = len(user_sessions)
        active_processing = len(processing_users)

        stats_text = (
            f"üìà **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ TabFix:**\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\n"
            f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç–æ–∫: {active_processing}\n"
            f"‚Ä¢ –í–µ—Ä—Å–∏—è –º–æ–¥—É–ª—è: 2.2\n"
            f"‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∞—Ä—Ö–∏–≤–æ–≤: ‚úì\n"
            f"‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–∞—Ä–æ–ª–µ–π: ‚úì\n"
            f"‚Ä¢ –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞: ‚úì"
        )

        buttons = [
            Button.inline("–û—á–∏—Å—Ç–∏—Ç—å —Å–µ—Å—Å–∏–∏", b"clear_sessions"),
            Button.inline("–°–ø—Ä–∞–≤–∫–∞", b"show_help")
        ]

        await event.edit(stats_text, buttons=buttons)

    async def clear_sessions_handler(event):
        for session in user_sessions.values():
            session.cleanup()
        user_sessions.clear()
        processing_users.clear()
        await event.edit("‚úÖ –í—Å–µ —Å–µ—Å—Å–∏–∏ –æ—á–∏—â–µ–Ω—ã")

    async def show_help_handler(event):
        help_text = (
            "üìñ **TabFix Module v2.2**\n\n"
            "**–ù–æ–≤—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª:**\n"
            "‚Ä¢ –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–æ–≤\n"
            "‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ ZIP –∞—Ä—Ö–∏–≤–æ–≤\n"
            "‚Ä¢ –ó–∞—â–∏—â–µ–Ω–Ω—ã–µ –ø–∞—Ä–æ–ª–µ–º –∞—Ä—Ö–∏–≤—ã (--password)\n"
            "‚Ä¢ –í–æ–∑–≤—Ä–∞—Ç –≤ –≤–∏–¥–µ –∞—Ä—Ö–∏–≤–∞ (--zip)\n"
            "‚Ä¢ –°—Ç–∞—Ç—É—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏\n"
            "‚Ä¢ –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–π\n"
            "‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
            "**–í–∞–∂–Ω–æ:** –î–ª—è –∞—Ä—Ö–∏–≤–æ–≤ —Å –ø–∞—Ä–æ–ª–µ–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
            "`.tabfix --zip --password 123`\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.tabfix help` –¥–ª—è –ø–æ–ª–Ω–æ–π —Å–ø—Ä–∞–≤–∫–∏."
        )
        await event.edit(help_text)

    kernel.register_callback_handler('clear_sessions', clear_sessions_handler)
    kernel.register_callback_handler('show_help', show_help_handler)
